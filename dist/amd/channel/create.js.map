{"version":3,"sources":["../../../src/channel/create.js"],"names":[],"mappings":"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","file":"src/channel/create.js","sourcesContent":["'use strict';\n// global registry\nvar channels = {};\n\nmodule.exports = ChannelsProvider;\n\n// accessor function\n// allows non-existent channels usage\n// gives sane warning message\nchannels.get = function (name) {\n  if (!channels[name]) {\n    console.log('Warning! The non-existent channel is accessed: ' + name +\n      '.\\n' + 'This is potentially abnormal situation: all active channels should ' +\n      'be created using channelsProvider.createChannels(<array>) ' +\n      'or registered using the screen\\'s \"channels\" field.');\n    return new Channel(name);\n  }\n\n  return channels[name];\n};\n\nfunction Channel (name) {\n  // channel name\n  this.name = name;\n\n  // all scopes linked to this channel\n  this.scopes = [];\n\n  // all source states linked to this channel\n  this.sources = [];\n\n  // all target states linked to this channel\n  this.targets = [];\n\n  // transformation function\n  // (target, source) -> newTarget\n  this.transform = function (nothing, x) {\n    return x;\n  };\n}\n\n// angular-specific provider format\nfunction ChannelsProvider () {\n\n  function add (name) {\n    channels[name] = new Channel(name);\n  }\n\n  // this should be called during app startup to create the given channels\n  this.createChannels = function (array) {\n    array.forEach(add);\n  };\n\n  this.$get = ['$rootScope', ChannelFactory];\n}\n\n// this thing will be injected in angular\nfunction ChannelFactory ($rootScope) {\n  // links the given scope to this channel\n  // any change will be propagated to this scope\n  Channel.prototype.link = function (scope) {\n    if (this.scopes.indexOf(scope) > -1) {\n      return;\n    }\n\n    this.scopes.push(scope);\n    return this;\n  };\n\n  Channel.prototype.source = function (state, field) {\n    if (!this.scopes.length) {\n      throw new Error('Channel' + this.name + 'is not linked to any scope!\\n' +\n        'All active channels should be linked to at least ' +\n        'one scope to be able to watch state changes.' +\n        'Use channel.link(scope)');\n    }\n\n    this.sources.push({\n      state: state,\n      field: field\n    });\n\n\n    if (typeof state[field] === 'function') {\n      return this.fromFn(state, field);\n    }\n\n    var watched = function () {\n      return state[field];\n    };\n\n    if (!field) {\n      watched = function () {\n        return state;\n      };\n    }\n\n    var watchHandler = function (n, o) {\n      if (n !== o) {\n        this._dispatch(state);\n      }\n    }.bind(this);\n\n    var scope = this.scopes[this.scopes.length - 1];\n\n    //deep watch object if no field defined\n    scope.$watch(watched, watchHandler, !field);\n\n    return this;\n  };\n\n  Channel.prototype.fromFn = function (state, fnName) {\n    // remember old function\n    var oldFn = state[fnName];\n\n    // hijack with decorator\n    state[fnName] = function () {\n      var args = [].slice.apply(arguments);\n\n      var result = oldFn.apply(state, args);\n\n      // dispatch change when this method is called\n      // todo pass the source state anyway?\n      this._dispatch(result);\n    }.bind(this);\n\n    return this;\n  };\n\n  Channel.prototype._dispatch = function (sourceState) {\n    $rootScope.$broadcast(this.name, sourceState);\n  };\n\n  Channel.prototype.map = function (fn) {\n    // (target, source) -> target\n    this.transformer = fn;\n    return this;\n  };\n\n  // Bind the given state to all changes in this channel\n  Channel.prototype.linkWith = function (targetScope, state) {\n    var listenTarget = {\n      state: state,\n      scope: targetScope\n    };\n\n    this.targets.push(listenTarget);\n\n    // binding to target scope so that listener deregisters automatically\n    return targetScope.$on(this.name, function (event, sourceState) {\n      var result = this.transformer(state, sourceState);\n      if (result === undefined) {\n        console.log('Warning! The channel \"' + this.name +\n          '\" has resetted the target state to \"undefined\"!' +\n          '\\nDo you really want this?' +\n          '\\nMaybe you should use a pure function inside channel.map().' +\n          '\\nThis function should return transformed state object:\\n' + this.transformer);\n      }\n      targetScope.state = result;\n    }.bind(this));\n  };\n\n  return channels;\n}\n"]}