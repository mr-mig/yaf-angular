{"version":3,"sources":["../../../src/channel/create.js"],"names":[],"mappings":"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","file":"src/channel/create.js","sourcesContent":["'use strict';\n// global registry\nvar channels = {};\n\nmodule.exports = ChannelsProvider;\n\n// accessor function\n// allows non-existent channels usage\n// gives sane warning message\nchannels.get = function (name) {\n  if (!channels[name]) {\n    console.log('Warning! The non-existent channel is accessed: ' + name + '.\\n' +\n      'This is potentially abnormal situation: all active channels should ' +\n      'be created using channelsProvider.createChannels(<array>) ' +\n      'or registered using the screen\\'s \"channels\" field.');\n    return new Channel(name);\n  }\n\n  return channels[name];\n};\n\nfunction Channel(name) {\n  // channel name\n  this.name = name;\n\n  // all scopes linked to this channel\n  this.scopes = [];\n\n  // all source states linked to this channel\n  this.sources = [];\n\n  // all target states linked to this channel\n  this.targets = [];\n\n  // transformation function\n  // (target, source) -> newTarget\n  this.transform = function (nothing, x) {\n    return x;\n  };\n}\n\n// angular-specific provider format\nfunction ChannelsProvider() {\n\n  function add(name) {\n    channels[name] = new Channel(name);\n  }\n\n  // this should be called during app startup to create the given channels\n  this.createChannels = function (array) {\n    array.forEach(add);\n  };\n\n  this.$get = ['$rootScope', ChannelFactory];\n}\n\n// this thing will be injected in angular\nfunction ChannelFactory($rootScope) {\n  // links the given scope to this channel\n  // any change will be propagated to this scope\n  Channel.prototype.link = function (scope) {\n    if (this.scopes.indexOf(scope) > -1) {\n      return;\n    }\n\n    this.scopes.push(scope);\n    return this;\n  };\n\n  Channel.prototype.source = function (state, field) {\n    if (!this.scopes.length) {\n      throw new Error('Channel' + this.name + 'is not linked to any scope!\\n' +\n        'All active channels should be linked to at least one scope to be able to watch state changes.' +\n        'Use channel.link(scope)');\n    }\n\n    this.sources.push({\n      state: state,\n      field: field\n    });\n\n\n    if (typeof state[field] === 'function') {\n      return this.fromFn(state, field);\n    }\n\n    var watched = function () {\n      return state[field];\n    };\n\n    if (!field) watched = function () {\n      return state;\n    };\n\n    var watchHandler = function (n, o) {\n      if (n !== o) {\n        this._dispatch(state);\n      }\n    }.bind(this);\n\n    var scope = this.scopes[this.scopes.length - 1];\n\n    //deep watch object if no field defined\n    scope.$watch(watched, watchHandler, !field);\n\n    return this;\n  };\n\n  Channel.prototype.fromFn = function (state, fnName) {\n    // remember old function\n    var oldFn = state[fnName];\n\n    // hijack with decorator\n    state[fnName] = function () {\n      var args = [].slice.apply(arguments);\n\n      var result = oldFn.apply(state, args);\n\n      // dispatch change when this method is called\n      // todo pass the source state anyway?\n      this._dispatch(result);\n    }.bind(this);\n\n    return this;\n  };\n\n  Channel.prototype._dispatch = function (sourceState) {\n    $rootScope.$broadcast(this.name, sourceState);\n  };\n\n  Channel.prototype.map = function (fn) {\n    // (target, source) -> target\n    this.transformer = fn;\n    return this;\n  };\n\n  // Bind the given state to all changes in this channel\n  Channel.prototype.linkWith = function (targetScope, state) {\n    var listenTarget = {\n      state: state,\n      scope: targetScope\n    };\n\n    this.targets.push(listenTarget);\n\n    // binding to target scope so that listener deregisters automatically\n    return targetScope.$on(this.name, function (event, sourceState) {\n      var result = this.transformer(state, sourceState);\n      if (result === undefined) {\n        console.log('Warning! The channel \"' + this.name +\n          '\" has resetted the target state to \"undefined\"!' +\n          '\\nDo you really want this?' +\n          '\\nMaybe you should use a pure function inside channel.map().' +\n          '\\nThis function should return transformed state object:' +\n          '\\n' + this.transformer);\n      }\n      targetScope.state = result;\n    }.bind(this));\n  };\n\n  return channels;\n}"]}